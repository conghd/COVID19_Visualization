<html>

<head>
    <style>
        body {
            font-family: Helvetica, Arial, sans-serif
        }

        h1 {
            background-color: #2a5599;
            color: white;
            padding: 5px;
        }

        svg {
            border: black solid 1px;
            width: 100%;
        }

        .mainView {
            display: flex;
            flex-direction: row;
        }
        .mainView div {
            flex: 1;
        }
    </style>
    <script src="d3.js"></script> 
</head>

<body>
    <h1>Airlines Routes</h1>
    <div class="mainView">
        <div>
            <h2>Airlines</h2>
            <svg id="AirlinesChart"></svg>
        </div>
        <div>
            <h2>Airports</h2>
            <svg id="Map" width="600" height="400"></svg>
        </div>
    </div>
</body>
<script>
    let store = {}

    function loadData() {
        return Promise.all([
            d3.csv("routes.csv"),
            d3.json("countries.geo.json"),
        ]).then(datasets => {
            store.routes = datasets[0],
            store.geoJSON = datasets[1]

            return store;
        })
    }

    function groupByAirline(data) {
        //Iterate over each route, producing a dictionary where the keys is are the ailines ids and the values are the information of the airline.
        let result = data.reduce((result, d) => {
            let currentData = result[d.AirlineID] || {
                "AirlineID": d.AirlineID,
                "AirlineName": d.AirlineName,
                "Count": 0
            }
            
            currentData.Count += 1//TODO: Increment the count (number of routes) of ariline.
            
            result[d.AirlineID] = currentData //TODO: Save the updated information in the dictionary using the airline id as key.

            return result;
        }, {})

        //We use this to convert the dictionary produced by the code above, into a list, that will make it easier to create the visualization. 
        result = Object.keys(result).map(key => result[key])
        result = result.sort((a, b) => {
            return d3.descending(a.Count, b.Count)
        })
        //TODO: Sort the data in descending order of count.

        return result
    }

    function drawAirlinesChart(airlines) {
        let config = getAirlinesChartConfig();
        let scales = getAirlinesChartScales(airlines, config);
        drawBarsAirlinesChart(airlines, scales, config);
        drawAxesAirlinesChart(airlines, scales, config);
    }

    function drawBarsAirlinesChart(airlines, scales, config) {
        let { margin, container } = config;
        let { xScale, yScale } = scales;
        let body = container.append("g")
                .style("transform", `translate(${margin.left}px,${margin.top}px)`)
        let bars = body.selectAll(".bar")
                        .data(airlines)
        bars.enter().append("rect")
            .attr("height", yScale.bandwidth())
            .attr("y", (d) => yScale(d.AirlineName))
            .attr("width", d => xScale(d.Count))
            .attr("fill", "#2a5599")

    }

    function showData() {
      //Get the routes from our store variable
      let routes = store.routes
      // Compute the number of routes per airline.
      let airlines = groupByAirline(store.routes);
      console.log(airlines)

      // Draw airlines barchart
      drawAirlinesChart(airlines);
      drawMap(store.geoJSON);
    }

    function getAirlinesChartConfig() {
        let width = 350;
        let height = 400;
        let margin = {
            top: 10,
            bottom: 50,
            left: 130,
            right: 10
        }
        let bodyHeight = height - margin.top - margin.bottom;
        let bodyWidth = width - margin.left - margin.right;

        let container = d3.select("#AirlinesChart")
        container
            .attr("width", width)
            .attr("height", height)

        return { width, height, margin, bodyHeight, bodyWidth, container }
    }

    function getAirlinesChartScales(airlines, config) {
        let { bodyWidth, bodyHeight } = config;
        let maximumCount = d3.max(airlines, airline => airline.Count)

        let xScale =
            d3.scaleLinear()
              .range([0, bodyWidth])
              .domain([0, maximumCount])

        let yScale =
            d3.scaleBand()
              .range([0, bodyHeight])
              .domain(airlines.map(a => a.AirlineName))
              .padding(0.2)

        return { xScale, yScale }

    }

    function drawAxesAirlinesChart(airlines, scales, config) {
        let { xScale, yScale } = scales;
        let { container, margin, height } = config;
        let axisX = d3.axisBottom(xScale)
            .ticks(5)
        container.append("g")
            .style("transform",
                `translate(${margin.left}px,${height - margin.bottom}px)`
            )
            .call(axisX)

        let yAxis = d3.axisLeft(yScale)
        container.append("g")
            .style("transform",
                `translate(${margin.left}px, ${margin.top}px)`
            )
            .call(yAxis)
    }

    //=============================================
    function getMapConfig() {
        let width = 600;
        let height = 400;
        let container = d3.select("#Map")//TODO: select the svg with id Map
            //TODO: set the width and height of the conatiner to be equal the width and height variables.
        return {width, height, container}
    }

    function getMapProjection(config) {
        let {width, height} = config;
        let projection = //TODO: Create a projection of type Mercator.
            d3.geoMercator();

        projection.scale(97)
                  .translate([width / 2, height / 2 + 20])

        store.mapProjection = projection;
        return projection;
    }

    function drawBaseMap(container, countries, projection){
        let path = //TODO: create a geoPath generator and set its projection to be the projection passed as parameter.
            d3.geoPath().projection(projection)
  
        container.selectAll("path").data(countries)
            .enter().append("path")
            .attr("d", d => path(d))
            .attr("stroke", "#ccc")
            .attr("fill", "#eee")

    }

    function drawMap(geoJeon) {
        let config = getMapConfig();
        let projection = getMapProjection(config)
        drawBaseMap(config.container, geoJeon.features, projection)
    }

    function groupByAirport(data) {
        //We use reduce to transform a list into a object where each key points to an aiport. This way makes it easy to check if is the first time we are seeing the airport.
        let result = data.reduce((result, d) => {
            //The || sign in the line below means that in case the first option is anything that Javascript consider false (this insclude undefined, null and 0), the second option will be used. Here if result[d.DestAirportID] is false, it means that this is the first time we are seeing the airport, so we will create a new one (second part after ||)
            
            let currentDest = result[d.DestAirportID] || {
                "AirportID": d.DestAirportID,
                "Airport": d.DestAirport,
                "Latitude": +d.DestLatitude,
                "Longitude": +d.DestLongitude,
                "City": d.DestCity,
                "Country": d.DestCountry,
                "Count": 0
            }
            currentDest.Count += 1
            result[d.DestAirportID] = currentDest
        
            //After doing for the destination airport, we also update the airport the airplane is departing from.
            let currentSource = result[d.SourceAirportID] || {
                "AirportID": d.SourceAirportID,
                "Airport": d.SourceAirport,
                "Latitude": +d.SourceLatitude,
                "Longitude": +d.SourceLongitude,
                "City": d.SourceCity,
                "Country": d.SourceCountry,
                "Count": 0
            }
            currentSource.Count += 1
            result[d.SourceAirportID] = currentSource
        
            return result
        }, {})
        
        //We map the keys to the actual ariorts, this is an way to transform the object we got in the previous step into a list.
        result = Object.keys(result).map(key => result[key])
        return result
    }
    loadData().then(showData);
</script>
</html>